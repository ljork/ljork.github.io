[{"title":"网站浏览器崩溃原因分析","date":"2017-02-08T13:31:57.000Z","path":"2017/02/08/网站浏览器崩溃原因分析/","text":"其实在网页在装载的过程中，常常由于种种原因使浏览器的反映变的很慢，或造成浏览器失去响应，甚至会导致机器无法进行其他的操作。 对于访客，如果登录您网站，浏览器就立刻崩溃，我想这对谁都是无法容忍的，对此总结了网站导致浏览器崩溃的原因： 1. 内存泄漏 先谈下内存泄漏，网站由于内存泄漏的而照成崩溃有两种情况，服务器的崩溃和浏览器的崩溃。内存泄漏所造成的问题是显而易见的，它使得已分配的内存的引用就会丢失，只要系统还在运行中，则进程就会一直使用该内存。这样的结果是，曾占用更多的内存的程序会降低系统性能，直到机器完全停止工作，才会完全清空内存。 Apache的Web服务器是用C/C++编写的，C/C++的内存泄漏问题不必多说，系统中存在无法回收的内存，有时候会造成内存不足或系统崩溃。在Java中，内存泄漏就是存在一些被分配的可达而无用的对象，这些对象不会被GC所回收，然而它却占用内存。 而在客户端，JavaScript所造成的内存泄漏，也将可能使得浏览器崩溃。 JavaScript 是一种垃圾收集式（garbage collector，GC）语言，这就是说，内存是根据对象的创建分配给该对象的，并会在没有对该对象的引用时由浏览器收回。同时浏览器处理JavaScript并非采用纯粹的垃圾收集，还使用引用计数来为Native对象(例如Dom、ActiveX Object)处理内存。 在引用计数系统，每个所引用的对象都会保留一个计数，以获悉有多少对象正在引用它。如果计数为零，该对象就会被销毁，其占用的内存也会返回给堆。 当对象相互引用时，就构成循环引用，浏览器（IE6，Firefox2.0）对于纯粹的JavaScript对象间的循环引用是可以正确处理的，但由于在引用计数系统，相互引用的对象都不能被销毁，因为是引用计数永远不能为零，因此浏览器无法处理JavaScript与Native对象(例如Dom、ActiveX Object)之间循环引用。所以，当我们出现Native对象与JavaScript对象间的循环引用时，就会出现内存泄漏的问题。 简单来说就是，浏览器使用引用计数来为Native对象处理内存，而引用计数的对象无法被销毁，涉及Native对象的循环引用将会出现内存泄漏。配合下面的例子，理解这句话，基本上就可以理解JavaScript造成的内存泄漏了。 1234567var obj; window.onload = function()&#123; // JavaScript对象obj到DOM对象的引用，根据id获得 obj=document.getElementById(\"DivElement\"); // DOM 对象则有到此 JavaScript 对象的引用，由expandoProperty实现 document.getElementById(\"DivElement\").expandoProperty=obj; &#125;; 可见，JavaScript 对象和 DOM 对象间就产生了一个循环引用。由于 DOM 对象是通过引用计数管理的，所以两个对象将都不能销毁。 另一种情况是闭包中，当碰到闭包，我们在Native对象上绑定事件响应代码时，很容易制造出Closure Memory Leak。其关键原因和前者是一样的，也是一个跨JavaScript对象和Native对象的循环引用。只是代码更为隐蔽。12345678window.onload = function AttachEvents(element)&#123; //element有个引用指向函数ClickEventHandler() element.attachEvent( \" onclick \" , ClickEventHandler); function ClickEventHandler()&#123; //该函数有个引用指向AttachEvents(element)调用Scope， //也就是执行了参数element。 &#125; &#125; 这里简单理解了JavaScript造成内存泄漏的原因，内存泄漏加大浏览器的负担，很有可能导致浏览器崩溃，我们要做的就是尽量去避免这种情况。处理JavaScript内存泄漏最终目的还是要打破JavaScript对象和Native对象间的循环引用或者清零引用计数，释放对象。 2.网页代码复杂和浏览器bug 大量个人网站和低质量网站代码的涌现造成对浏览标准的普遍不支持，如果正好碰上浏览器存在的一些bug，浏览器渲染引擎在处理这些网页代码的时候会出错，比如陷入死循环或直接崩溃等。 3. 网页数据过多 网页含有大量需要处理的数据，造成系统繁忙，如多图页面，超长页面等，或者网页内嵌的各种控件会导致浏览器处理大量数据，造成系统繁忙。如Flash游戏，ActiveX控件等。当浏览器访问网站的时候，如果网站的数据量大，会使得浏览器一般在处理过程中会占用很大的CPU使用率和内存、造成浏览器失去响应，甚至会使电脑系统死机。在网站开发的时候，如果充分考虑Web性能，很大程度上能避免这个问题。 4.Ajax的Web服务漏洞 Ajax的是基于XML的异步传输，文本格式的XML消息可能是二进制数据带宽量的两倍之多。传输XML消息所需的带宽越多，系统或应用程序用来执行其他任务的可用资源就越少。例如执行复杂算法来获取期望结果。 过高的带宽可能导致由系统超载引起的性能减退。过高的带宽将导致Ajax应用程序输出破损的数据，因为没有足够的资源生成干净的数据。这意味着Web服务门户(Ajax应用程序属于其中的一部分)将把破损数据暴露给门户的其他部分，从而导致畸形消息和过度解析。如果威胁者利用了这个漏洞，则会引起浏览器崩溃。 另外一方面，频繁的、较小的 HTTP 请求会加重后端服务器、负载均衡程序和防火墙的负担，结果是造成过高的带宽，最终导致性能降低。如果客户端长期停留在该页面或没有关闭浏览器，会使得浏览器的内存持续上涨，得不到释放，导致客户端浏览器崩溃。 为此，在较多的时候Ajax的时候，我们要考虑通过专门的硬件加速器、优化软件、消除代码冗余、XML加速功能和解决互操作性问题等方式加速Ajax应用程序。另外，积极地监视通信流可以持续地度量Ajax应用程序的网络流量性能。通过将数据放入实时日志中，您可以查看在哪些位置何时出现大量的包丢失和抖动事件，响应变慢的原因以及如何通过修改应用程序的优先级来改善通信流性能。 5.其他原因 除以上提到的原因之外，还有其他许多原因，虽然有些不会导致浏览器直接崩溃，但也会造成网站无法访问，如日志文件导致磁盘已满、Web服务器C指针错误、进程缺乏文件描述符、线程死锁、数据库中的临时表不够用和服务器超载等","tags":[{"name":"浏览器奔溃","slug":"浏览器奔溃","permalink":"http://yoursite.com/tags/浏览器奔溃/"},{"name":"前端优化","slug":"前端优化","permalink":"http://yoursite.com/tags/前端优化/"}]},{"title":"Git常用命令","date":"2017-01-23T12:20:42.000Z","path":"2017/01/23/Git常用命令/","text":"初始化配置12345678910111213141516171819#配置使用git仓库的人员姓名 git config --global user.name &quot;Your Name Comes Here&quot; #配置使用git仓库的人员email git config --global user.email you@yourdomain.example.com #配置到缓存 默认15分钟 git config --global credential.helper cache #修改缓存时间 git config --global credential.helper &apos;cache --timeout=3600&apos; git config --global color.ui true git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmate git config -1 #列举所有配置 查看、添加、提交、删除、找回，重置修改文件12345678910111213141516171819202122232425git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot; git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diff1234567git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异 git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异 git diff --cached # 比较暂存区和版本库差异 git diff --stat # 仅仅比较统计信息 查看提交记录12345git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat #查看提交统计信息 取得Git仓库1234567891011#初始化一个版本仓库 git init #Clone远程版本库 git clone git@xbc.me:wordpress.git #添加远程版本库origin，语法为 git remote add [shortname] [url] git remote add origin git@xbc.me:wordpress.git #查看远程仓库 git remote -v 提交你的修改123456789101112131415161718192021222324252627282930313233343536373839404142434445#添加当前修改的文件到暂存区 git add . #如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件 git add -u #提交你的修改 git commit –m &quot;你的注释&quot; #推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支] git push origin master #查看文件状态 git status #跟踪新文件 git add readme.txt #从当前跟踪列表移除文件，并完全删除 git rm readme.txt #仅在暂存区删除，保留文件在当前目录，不再跟踪 git rm –cached readme.txt #重命名文件 git mv reademe.txt readme #查看提交的历史记录 git log #修改最后一次提交注释的，利用–amend参数 git commit --amend #忘记提交某些修改，下面的三条命令只会得到一个提交。 git commit –m &amp;quot;add readme.txt&amp;quot; git add readme_forgotten git commit –amend #假设你已经使用git add .，将修改过的文件a、b加到暂存区 #现在你只想提交a文件，不想提交b文件，应该这样 git reset HEAD b #取消对文件的修改 git checkout –- readme.txt 查看、切换、创建和删除分支123456789101112131415git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br --merged # 查看已经被合并到当前分支的分支 git br --no-merged # 查看尚未被合并到当前分支的分支 git co &lt;branch&gt; # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d &lt;branch&gt; # 删除某个分支 git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase12345git merge &lt;branch&gt; # 将branch分支合并到当前分支 git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理1234git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理12345678910111213git pull # 抓取远程仓库所有分支更新并合并到本地 git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 基本的分支管理1234567891011121314151617181920212223242526#创建一个分支 git branch iss53 #切换工作目录到iss53 git chekcout iss53 #将上面的命令合在一起，创建iss53分支并切换到iss53 git chekcout –b iss53 #合并iss53分支，当前工作目录为master git merge iss53 #合并完成后，没有出现冲突，删除iss53分支 git branch –d iss53 #拉去远程仓库的数据，语法为 git fetch [remote-name] git fetch #fetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并 git pull #查看远程仓库的信息 git remote show origin #建立本地的dev分支追踪远程仓库的develop分支 git checkout –b dev origin/develop Git远程仓库管理12345git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库123456789git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"输入url后的加载过程","date":"2017-01-05T14:22:40.000Z","path":"2017/01/05/输入url后的加载过程/","text":"输入url后的加载过程###计算机网络体系结构 应用层(HTTP、SMTP、FTP、POP3) 运输层(TCP、UDP) 网络层(IP(路由器)) 数据链路层(网桥(CSMA/CD、PPP)) 物理层(集线器) 1、查找域名对应IP地址这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… (1) 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； (2) 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； (3) 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； (4) 操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求： ①LDNS 向 Root Name Server （根域名服务器，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址； ② LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址； ③ LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址； (5) LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； (6) 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 2、建立连接(TCP的三次握手)(1) 主机向服务器发送一个建立连接的请求； (2) 服务器接到请求后发送同意连接的信号； (3) 主机接到同意连接的信号后，再次向服务器发送了确认信号 ; 1注意：这里的三次握手中主机两次向服务器发送确认，第二次是为了防止已失效的连接请求报文段传至服务器导致错误。 3、构建网页(1) 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等； (2) 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； (3) 服务器将得到的 HTML 文件发送给浏览器； (4) 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； (5) 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、音频、视频、CSS、JS等文件，过程同请求 HTML ； 1234567浏览器渲染展示网页过程1. HTML代码转化为DOM(DOM Tree)2. CSS代码转化成CSSOM（CSS Object Model）3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）(Render Tree)4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成5. 将布局绘制（paint）在屏幕上 4. 断开连接(TCP的四次挥手)(1) 主机向服务器发送一个断开连接的请求； (2) 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机) (3) 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据) (4) 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接； 1注意：这里的四次挥手中服务器两次向主机发送消息，第一次是回复主机已收到断开的请求，第二次是向主机确认是否断开，确保数据传输完毕。","tags":[{"name":"网络技术","slug":"网络技术","permalink":"http://yoursite.com/tags/网络技术/"}]},{"title":"js性能优化","date":"2016-11-26T12:09:35.000Z","path":"2016/11/26/js性能优化/","text":"js性能优化下面是一些关于客户端JS性能的一些优化的小技巧：1、关于JS的循环，循环是一种常用的流程控制。JS提供了三种循环：for(;;)、while()、for(in)。在这三种循环中 for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;;)、while()循环的性能基本持平。当然，推 荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的++或－－运算符。 2、如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。 3、局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。 4.尽量少使用eval，每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。 5.尽量避免对象的嵌套查询，对于obj1.obj2.obj3.obj4这个语句，需要进行至少3次查询操作，先检查obj1中是否包含 obj2，再检查obj2中是否包含obj3，然后检查obj3中是否包含obj4…这不是一个好策略。应该尽量利用局部变量，将obj4以局部变量 保存，从而避免嵌套查询。 6.使运算符时，尽量使用+＝，－＝、*＝、\\=等运算符号，而不是直接进行赋值运算。 7.[顶]当需要将数字转换成字符时，采用如下方式：”” + 1。从性能上来看，将数字转换成字符时，有如下公式：(“” +) &gt; String() &gt; .toString() &gt; new String()。String()属于内部函数，所以速度很快。而.toString()要查询原型中的函数，所以速度逊色一些，new String()需要重新创建一个字符串对象，速度最慢。 8.[顶]当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法用于将字符串转换成数字。而且Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用时间，速度是最快的。 9.尽量作用JSON格式来创建对象，而不是var obj=new Object()方法。因为前者是直接复制，而后者需要调用构造器，因而前者的性能更好。 10.当需要使用数组时，也尽量使用JSON格式的语法，即直接使用如下语法定义数组：[parrm,param,param…],而不是采用 new Array(parrm,param,param…)这种语法。因为使用JSON格式的语法是引擎直接解释的。而后者则需要调用Array的构造器。 11.[顶]对字符串进行循环操作，例如替换、查找，就使用正则表达式。因为JS的循环速度比较慢，而正则表达式的操作是用C写成的API，性能比较好。 最后有一个基本原则，对于大的JS对象，因为创建时时间和空间的开销都比较大，因此应该尽量考虑采用缓存。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"javaScript封装的各种写法","date":"2016-10-27T14:09:05.000Z","path":"2016/10/27/javaScript封装的各种写法/","text":"通常写js组件开发的，都会用到匿名函数的写法去封装一个对象，与外界形成一个闭包的作用域。 主要对封装进行研究，因为前后台都会涉及到面向对象的概念，对于封装，怎么封装，封装的性能，等等很重要概念。封装（在程序世界是第一概念，我个人认为），全天下漫天遍野的封装，JQuery，EXT和Prototype.js封装的是javascript，jQuery uI和jQuery mobile封装着jQuery 回到主题javaScript封装写法，先来看看一个简单的：1234function hello()&#123; var a = 'hello'; alert(a);&#125; js函数是最原始，最基础的封装，懂js一目了然，如果你的页面不需要很多js交互操作，就可以用这种简单的方式，如果你喜欢用JQuery,则需要写成这样12345$(function()&#123; $('#id').click(function()&#123; alert('hello'); &#125;)&#125;); 如果用Node.js则比较复杂点，因为要Node.js要加载一个HTTP模块，写法如下：12345var http = require('http');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html'&#125;); res.write('&lt;p&gt;hello&lt;/p&gt;');&#125;).listen(8080); 再深层次封装写法，如果遇到大量使用js操作，单凭每个小的函数无法满足，因为它们存在一个公共的域中，写法多而散很容易造成了很多bug因素，需要规整。js创造者给我们提供了一个叫匿名函数，顾名思义，匿名函数就是没有实际名字的函数，它的格式很多种，！function(){}(),(function(){})(),(function(){}()),new function(){},void function(){}();JQuery.js就是一个匿名函数封装,先看最常用的:12345(function()&#123; star.init = (function(name)&#123; var e = new Editor(name, Data.toolbarData); &#125;); &#125;)() 如果开发一些js组件的时候，可以先创建一个对象，给这个对象属性和方法，让这个对象能够单独操作和可以和其他对象合作123456789101112131415161718192021222324252627282930var klm = klm || &#123;&#125;; klm = (function()&#123; //第一个写法 klm.init = function()&#123; alert('hello'); &#125; //第二个写法 klm.browser = (function(ua)&#123; var b = &#123; msie:/msie/.test(ua) &amp;&amp; !/opera/.test(ua), opera:/opera/.test(ua), safari:/webkit/.test(ua) &amp;&amp; !/chrome/.test(ua), firefox:/firefox/.test(ua), chrome:/chrome/.test(ua) &#125;; &#125;)(window.navigator.userAgent.toLowerCase()); //将其定义方法以接口方式返回给外界引用 return&#123; init: klm.init, browser:klm.browser &#125; &#125;)(); 接下来这种js封装写法是我自己比较喜欢的 123456789101112131415161718 var myOpinion = myOpinion || &#123;&#125;;myOpinion.prototype=&#123; init:function(obj,i)&#123; alert('hello'); &#125;, closeWindow:function(obj,d)&#123; obj.click(function()&#123; d.hide(); &#125;); &#125; &#125; $(function()&#123; var my = myOpinion.prototype; my.init($(\".z-sidebar li em\"),$(\"#contact\")); $(\"#contact\").add(my.closeWindow($(\".z-sidebar li em\"),$(\"#contact\")));&#125;);&#125; 这种方式先通过prototype继承方式把每一个小的操作封装成属性，init和closeWindow，然后可以进行初始化加载如my.init();也可以绑定到某个操作事件上如$(“#contact”).add(my.closeWindow());这些封装一气而成。 还有定义单个属性封装 12345678910WinShow.create = function(c,body)&#123; var _head = '&lt;div class=\"+ c.heacss +\"&gt;&lt;span class=\"+ c.concss +\"&gt;' + c.title + '&lt;/span&gt;&lt;/div&gt;'; this.container.innerHTML = _head; return this.container; this.container.onclick = function(e)&#123; alert('hello'); &#125; &#125; 在这里我创建一个create属性以匿名函数形式封装一段HTML代码，并给这个 HTML代码绑定点击事件。 转载自：http://www.cnblogs.com/kuailingmin/p/3838322.html","tags":[{"name":"封装","slug":"封装","permalink":"http://yoursite.com/tags/封装/"}]},{"title":"Hello World","date":"2016-05-05T14:11:40.000Z","path":"2016/05/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]