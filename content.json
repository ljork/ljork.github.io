[{"title":"Git常用命令","date":"2017-01-23T12:20:42.000Z","path":"2017/01/23/Git常用命令/","text":"初始化配置12345678910111213141516171819#配置使用git仓库的人员姓名 git config --global user.name &quot;Your Name Comes Here&quot; #配置使用git仓库的人员email git config --global user.email you@yourdomain.example.com #配置到缓存 默认15分钟 git config --global credential.helper cache #修改缓存时间 git config --global credential.helper &apos;cache --timeout=3600&apos; git config --global color.ui true git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmate git config -1 #列举所有配置 查看、添加、提交、删除、找回，重置修改文件12345678910111213141516171819202122232425git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot; git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diff1234567git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异 git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异 git diff --cached # 比较暂存区和版本库差异 git diff --stat # 仅仅比较统计信息 查看提交记录12345git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat #查看提交统计信息 取得Git仓库1234567891011#初始化一个版本仓库 git init #Clone远程版本库 git clone git@xbc.me:wordpress.git #添加远程版本库origin，语法为 git remote add [shortname] [url] git remote add origin git@xbc.me:wordpress.git #查看远程仓库 git remote -v 提交你的修改123456789101112131415161718192021222324252627282930313233343536373839404142434445#添加当前修改的文件到暂存区 git add . #如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件 git add -u #提交你的修改 git commit –m &quot;你的注释&quot; #推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支] git push origin master #查看文件状态 git status #跟踪新文件 git add readme.txt #从当前跟踪列表移除文件，并完全删除 git rm readme.txt #仅在暂存区删除，保留文件在当前目录，不再跟踪 git rm –cached readme.txt #重命名文件 git mv reademe.txt readme #查看提交的历史记录 git log #修改最后一次提交注释的，利用–amend参数 git commit --amend #忘记提交某些修改，下面的三条命令只会得到一个提交。 git commit –m &amp;quot;add readme.txt&amp;quot; git add readme_forgotten git commit –amend #假设你已经使用git add .，将修改过的文件a、b加到暂存区 #现在你只想提交a文件，不想提交b文件，应该这样 git reset HEAD b #取消对文件的修改 git checkout –- readme.txt 查看、切换、创建和删除分支123456789101112131415git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br --merged # 查看已经被合并到当前分支的分支 git br --no-merged # 查看尚未被合并到当前分支的分支 git co &lt;branch&gt; # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d &lt;branch&gt; # 删除某个分支 git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase12345git merge &lt;branch&gt; # 将branch分支合并到当前分支 git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理1234git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理12345678910111213git pull # 抓取远程仓库所有分支更新并合并到本地 git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 基本的分支管理1234567891011121314151617181920212223242526#创建一个分支 git branch iss53 #切换工作目录到iss53 git chekcout iss53 #将上面的命令合在一起，创建iss53分支并切换到iss53 git chekcout –b iss53 #合并iss53分支，当前工作目录为master git merge iss53 #合并完成后，没有出现冲突，删除iss53分支 git branch –d iss53 #拉去远程仓库的数据，语法为 git fetch [remote-name] git fetch #fetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并 git pull #查看远程仓库的信息 git remote show origin #建立本地的dev分支追踪远程仓库的develop分支 git checkout –b dev origin/develop Git远程仓库管理12345git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库123456789git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"输入url后的加载过程","date":"2017-01-05T14:22:40.000Z","path":"2017/01/05/输入url后的加载过程/","text":"输入url后的加载过程###计算机网络体系结构 应用层(HTTP、SMTP、FTP、POP3) 运输层(TCP、UDP) 网络层(IP(路由器)) 数据链路层(网桥(CSMA/CD、PPP)) 物理层(集线器) 1、查找域名对应IP地址这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… (1) 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； (2) 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； (3) 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； (4) 操作系统将域名发送至 LDNS（本地区域名服务器），LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求： ①LDNS 向 Root Name Server （根域名服务器，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址； ② LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址； ③ LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址； (5) LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； (6) 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 2、建立连接(TCP的三次握手)(1) 主机向服务器发送一个建立连接的请求； (2) 服务器接到请求后发送同意连接的信号； (3) 主机接到同意连接的信号后，再次向服务器发送了确认信号 ; 1注意：这里的三次握手中主机两次向服务器发送确认，第二次是为了防止已失效的连接请求报文段传至服务器导致错误。 3、构建网页(1) 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等； (2) 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； (3) 服务器将得到的 HTML 文件发送给浏览器； (4) 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； (5) 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、音频、视频、CSS、JS等文件，过程同请求 HTML ； 1234567浏览器渲染展示网页过程1. HTML代码转化为DOM(DOM Tree)2. CSS代码转化成CSSOM（CSS Object Model）3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）(Render Tree)4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成5. 将布局绘制（paint）在屏幕上 4. 断开连接(TCP的四次挥手)(1) 主机向服务器发送一个断开连接的请求； (2) 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机) (3) 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据) (4) 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接； 1注意：这里的四次挥手中服务器两次向主机发送消息，第一次是回复主机已收到断开的请求，第二次是向主机确认是否断开，确保数据传输完毕。","tags":[{"name":"网络技术","slug":"网络技术","permalink":"http://yoursite.com/tags/网络技术/"}]},{"title":"js性能优化","date":"2016-11-26T12:09:35.000Z","path":"2016/11/26/js性能优化/","text":"js性能优化下面是一些关于客户端JS性能的一些优化的小技巧：1、关于JS的循环，循环是一种常用的流程控制。JS提供了三种循环：for(;;)、while()、for(in)。在这三种循环中 for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;;)、while()循环的性能基本持平。当然，推 荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的++或－－运算符。 2、如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。 3、局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。 4.尽量少使用eval，每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。 5.尽量避免对象的嵌套查询，对于obj1.obj2.obj3.obj4这个语句，需要进行至少3次查询操作，先检查obj1中是否包含 obj2，再检查obj2中是否包含obj3，然后检查obj3中是否包含obj4…这不是一个好策略。应该尽量利用局部变量，将obj4以局部变量 保存，从而避免嵌套查询。 6.使运算符时，尽量使用+＝，－＝、*＝、\\=等运算符号，而不是直接进行赋值运算。 7.[顶]当需要将数字转换成字符时，采用如下方式：”” + 1。从性能上来看，将数字转换成字符时，有如下公式：(“” +) &gt; String() &gt; .toString() &gt; new String()。String()属于内部函数，所以速度很快。而.toString()要查询原型中的函数，所以速度逊色一些，new String()需要重新创建一个字符串对象，速度最慢。 8.[顶]当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法用于将字符串转换成数字。而且Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用时间，速度是最快的。 9.尽量作用JSON格式来创建对象，而不是var obj=new Object()方法。因为前者是直接复制，而后者需要调用构造器，因而前者的性能更好。 10.当需要使用数组时，也尽量使用JSON格式的语法，即直接使用如下语法定义数组：[parrm,param,param…],而不是采用 new Array(parrm,param,param…)这种语法。因为使用JSON格式的语法是引擎直接解释的。而后者则需要调用Array的构造器。 11.[顶]对字符串进行循环操作，例如替换、查找，就使用正则表达式。因为JS的循环速度比较慢，而正则表达式的操作是用C写成的API，性能比较好。 最后有一个基本原则，对于大的JS对象，因为创建时时间和空间的开销都比较大，因此应该尽量考虑采用缓存。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"Hello World","date":"2016-05-05T14:11:40.000Z","path":"2016/05/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]